# 重构定时器

这一篇文章，我们来重构一下定时器。我们不使用`libuv`的定时器，而是自己去实现一个定时器。为什么要这么做呢？这里我很有必要花一些时间给大家说明一下。如果我们在循环里面去调用`Co::sleep`函数，会出现一些问题，或许在`PHP`层面上不会报错，但是，把`src`抽离出来，用`C++`代码做测试，就会发现这个问题。而且，如果我们的`timer`在堆上面分配内存的话，那么是不能够正常的释放`timer`的内存的，必须使用`libuv`的`uv_close`函数，在`uv_close`中的回调函数里面来释放，这就很头痛了。因为回调函数只能够通过`libuv`的那套事件驱动来被调用。但是，我们没有用到`libuv`的那套事件驱动，所以释放`timer`的回调函数就无法被调用，因此就会造成内存泄漏。这个问题花了我`1`天的时间去调试。主要是对`libuv`不熟悉，我还是在大佬的帮助下发现的这个问题。那么，为什么不使用`libuv`的那套事件驱动呢？因为，如果我们直接使用它的事件驱动，那么我们会失去很多学习的机会，而且我们的代码也会一直被`libuv`束缚住，这是我不希望看到的，所以，我决定自己去实现一个定时器，而且这个难道不是很大，因为`C++`有很多实用的容器，可以助力我们实现定时器。
